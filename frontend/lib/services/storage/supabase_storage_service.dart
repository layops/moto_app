import 'dart:io';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../config/supabase_config.dart';
import '../service_locator.dart';

class UploadResult {
  final bool success;
  final String? url;
  final String? error;

  UploadResult({
    required this.success,
    this.url,
    this.error,
  });
}

class SupabaseStorageService {
  // Backend ile uyumlu bucket isimleri kullan
  static const String _profileBucket = SupabaseConfig.profilePicturesBucket;
  static const String _coverBucket = SupabaseConfig.coverPicturesBucket;
  static const String _eventsBucket = SupabaseConfig.eventsPicturesBucket;
  static const String _groupsBucket = SupabaseConfig.groupsProfilePicturesBucket;
  static const String _postsBucket = SupabaseConfig.groupPostsImagesBucket;
  static const String _bikesBucket = SupabaseConfig.bikesImagesBucket;

  /// Profil fotoÄŸrafÄ± yÃ¼kleme
  Future<UploadResult> uploadProfilePicture(File imageFile) async {
    try {
      print('ðŸ”¥ SUPABASE PROFILE UPLOAD START');
      
      // Bucket'Ä±n var olup olmadÄ±ÄŸÄ±nÄ± kontrol et
      String bucketToUse = _profileBucket;
      try {
        final buckets = await Supabase.instance.client.storage.listBuckets();
        print('ðŸ”¥ Available buckets for profile: ${buckets.map((b) => b.name).toList()}');
        
        final profileBucketExists = buckets.any((bucket) => bucket.name == _profileBucket);
        if (!profileBucketExists) {
          print('ðŸ”¥ WARNING: Profile bucket $_profileBucket does not exist!');
          
          // Alternatif bucket'larÄ± dene
          final alternatives = ['moto-app-storage', 'cover_pictures', 'images', 'storage'];
          for (final altBucket in alternatives) {
            if (buckets.any((bucket) => bucket.name == altBucket)) {
              bucketToUse = altBucket;
              print('ðŸ”¥ Using alternative bucket for profile: $bucketToUse');
              break;
            }
          }
          
          // HiÃ§ bucket yoksa hata dÃ¶ndÃ¼r
          if (!buckets.any((bucket) => bucket.name == bucketToUse)) {
            return UploadResult(
              success: false,
              error: 'HiÃ§bir storage bucket bulunamadÄ±. LÃ¼tfen yÃ¶netici ile iletiÅŸime geÃ§in.',
            );
          }
        }
      } catch (bucketError) {
        print('ðŸ”¥ Profile bucket check error: $bucketError');
      }
      
      // KullanÄ±cÄ± ID'sini al
      final userId = await _getCurrentUserId();
      if (userId == null) {
        throw Exception('KullanÄ±cÄ± ID bulunamadÄ±');
      }
      
      // Eski profil fotoÄŸrafÄ±nÄ± sil
      await _deleteOldProfilePicture(userId, bucketToUse);
      
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final extension = imageFile.path.split('.').last;
      final fileName = 'profile_${timestamp}.$extension';
      final filePath = 'users/$userId/$fileName';
      
      print('ðŸ”¥ Profile file path: $filePath');
      print('ðŸ”¥ User ID: $userId');
      
      final response = await Supabase.instance.client.storage
          .from(bucketToUse)
          .upload(filePath, imageFile);

      print('ðŸ”¥ Profile upload response: $response');

      final publicUrl = Supabase.instance.client.storage
          .from(bucketToUse)
          .getPublicUrl(filePath);

      print('ðŸ”¥ Profile public URL: $publicUrl');

      return UploadResult(
        success: true,
        url: publicUrl,
      );
    } catch (e) {
      print('ðŸ”¥ SUPABASE PROFILE UPLOAD ERROR: $e');
      return UploadResult(
        success: false,
        error: e.toString(),
      );
    }
  }


  /// Supabase baÄŸlantÄ±sÄ±nÄ± test et
  Future<void> testSupabaseConnection() async {
    try {
      print('ðŸ”¥ TESTING SUPABASE CONNECTION...');
      print('ðŸ”¥ Supabase URL: ${SupabaseConfig.supabaseUrl}');
      print('ðŸ”¥ Supabase Key: ${SupabaseConfig.supabaseAnonKey.substring(0, 20)}...');
      
      // Storage bucket'larÄ±nÄ± test et
      try {
        final buckets = await Supabase.instance.client.storage.listBuckets();
        print('ðŸ”¥ Storage buckets test: SUCCESS');
        print('ðŸ”¥ Available buckets: ${buckets.map((b) => b.name).toList()}');
      } catch (storageError) {
        print('ðŸ”¥ Storage buckets test: FAILED - $storageError');
      }
      
      // Basit bir test yap (users tablosu yerine auth test)
      try {
        final user = Supabase.instance.client.auth.currentUser;
        print('ðŸ”¥ Auth test: SUCCESS - User: ${user?.email ?? "Anonymous"}');
      } catch (authError) {
        print('ðŸ”¥ Auth test: FAILED - $authError');
      }
    } catch (e) {
      print('ðŸ”¥ General connection test: FAILED - $e');
    }
  }

  /// Kapak fotoÄŸrafÄ± yÃ¼kleme
  Future<UploadResult> uploadCoverPicture(File imageFile) async {
    try {
      print('ðŸ”¥ SUPABASE COVER UPLOAD START');
      print('ðŸ”¥ Bucket: $_coverBucket');
      print('ðŸ”¥ File path: ${imageFile.path}');
      print('ðŸ”¥ File size: ${await imageFile.length()} bytes');
      
      // Supabase baÄŸlantÄ±sÄ±nÄ± test et
      await testSupabaseConnection();
      
      // Hardcoded bucket kullan (RLS sorunu nedeniyle)
      String bucketToUse = 'cover_pictures'; // Supabase'de mevcut bucket
      print('ðŸ”¥ Using hardcoded bucket: $bucketToUse');
      
      // KullanÄ±cÄ± ID'sini al
      final userId = await _getCurrentUserId();
      if (userId == null) {
        throw Exception('KullanÄ±cÄ± ID bulunamadÄ±');
      }
      
      // Eski kapak fotoÄŸrafÄ±nÄ± sil
      await _deleteOldCoverPicture(userId, bucketToUse);
      
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final extension = imageFile.path.split('.').last;
      final fileName = 'cover_${timestamp}.$extension';
      final filePath = 'users/$userId/$fileName';
      
      print('ðŸ”¥ File path: $filePath');
      print('ðŸ”¥ User ID: $userId');
      
      print('ðŸ”¥ Attempting upload to bucket: $bucketToUse');
      
      final response = await Supabase.instance.client.storage
          .from(bucketToUse)
          .upload(filePath, imageFile);

      print('ðŸ”¥ Upload response: $response');

      final publicUrl = Supabase.instance.client.storage
          .from(bucketToUse)
          .getPublicUrl(filePath);

      print('ðŸ”¥ Public URL: $publicUrl');

      return UploadResult(
        success: true,
        url: publicUrl,
      );
    } catch (e) {
      print('ðŸ”¥ SUPABASE COVER UPLOAD ERROR: $e');
      return UploadResult(
        success: false,
        error: e.toString(),
      );
    }
  }

  /// Post resmi yÃ¼kleme
  Future<UploadResult> uploadPostImage(File imageFile) async {
    try {
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final extension = imageFile.path.split('.').last;
      final fileName = 'post_${timestamp}.$extension';
      
      final response = await Supabase.instance.client.storage
          .from(_postsBucket)
          .upload(fileName, imageFile);

      final publicUrl = Supabase.instance.client.storage
          .from(_postsBucket)
          .getPublicUrl(fileName);

      return UploadResult(
        success: true,
        url: publicUrl,
      );
    } catch (e) {
      return UploadResult(
        success: false,
        error: e.toString(),
      );
    }
  }

  /// Etkinlik resmi yÃ¼kleme
  Future<UploadResult> uploadEventPicture(File imageFile) async {
    try {
      print('ðŸ”¥ SUPABASE EVENT UPLOAD START');
      
      // Mevcut event klasÃ¶rlerini kontrol et ve yeni numaralÄ± klasÃ¶r oluÅŸtur
      final nextFolderNumber = await _getNextEventFolderNumber();
      print('ðŸ”¥ Next event folder number: $nextFolderNumber');
      
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final extension = imageFile.path.split('.').last;
      final fileName = 'event_${timestamp}.$extension';
      
      // Dosya yolu: events/{folder_number}/{file_name}
      final filePath = 'events/$nextFolderNumber/$fileName';
      print('ðŸ”¥ Event file path: $filePath');
      
      final response = await Supabase.instance.client.storage
          .from(_eventsBucket)
          .upload(filePath, imageFile);

      print('ðŸ”¥ Event upload response: $response');

      final publicUrl = Supabase.instance.client.storage
          .from(_eventsBucket)
          .getPublicUrl(filePath);

      print('ðŸ”¥ Event public URL: $publicUrl');

      return UploadResult(
        success: true,
        url: publicUrl,
      );
    } catch (e) {
      print('ðŸ”¥ SUPABASE EVENT UPLOAD ERROR: $e');
      return UploadResult(
        success: false,
        error: e.toString(),
      );
    }
  }

  /// Grup resmi yÃ¼kleme
  Future<UploadResult> uploadGroupPicture(File imageFile) async {
    try {
      print('ðŸ”¥ SUPABASE GROUP UPLOAD START');
      
      // Mevcut grup klasÃ¶rlerini kontrol et ve yeni numaralÄ± klasÃ¶r oluÅŸtur
      final nextFolderNumber = await _getNextGroupFolderNumber();
      print('ðŸ”¥ Next group folder number: $nextFolderNumber');
      
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final extension = imageFile.path.split('.').last;
      final fileName = 'group_${timestamp}.$extension';
      
      // Dosya yolu: groups/{folder_number}/{file_name}
      final filePath = 'groups/$nextFolderNumber/$fileName';
      print('ðŸ”¥ Group file path: $filePath');
      
      final response = await Supabase.instance.client.storage
          .from(_groupsBucket)
          .upload(filePath, imageFile);

      print('ðŸ”¥ Group upload response: $response');

      final publicUrl = Supabase.instance.client.storage
          .from(_groupsBucket)
          .getPublicUrl(filePath);

      print('ðŸ”¥ Group public URL: $publicUrl');

      return UploadResult(
        success: true,
        url: publicUrl,
      );
    } catch (e) {
      print('ðŸ”¥ SUPABASE GROUP UPLOAD ERROR: $e');
      return UploadResult(
        success: false,
        error: e.toString(),
      );
    }
  }

  /// Dosya silme
  Future<bool> deleteFile(String fileName, String bucketType) async {
    try {
      String bucketName;
      switch (bucketType) {
        case 'profile':
          bucketName = _profileBucket;
          break;
        case 'cover':
          bucketName = _coverBucket;
          break;
        case 'events':
          bucketName = _eventsBucket;
          break;
        case 'groups':
          bucketName = _groupsBucket;
          break;
        case 'posts':
          bucketName = _postsBucket;
          break;
        case 'bikes':
          bucketName = _bikesBucket;
          break;
        default:
          return false;
      }
      
      await Supabase.instance.client.storage
          .from(bucketName)
          .remove([fileName]);
      return true;
    } catch (e) {
      return false;
    }
  }

  /// Public URL alma
  String getPublicUrl(String fileName, String bucketType) {
    String bucketName;
    switch (bucketType) {
      case 'profile':
        bucketName = _profileBucket;
        break;
      case 'cover':
        bucketName = _coverBucket;
        break;
      case 'events':
        bucketName = _eventsBucket;
        break;
      case 'groups':
        bucketName = _groupsBucket;
        break;
      case 'posts':
        bucketName = _postsBucket;
        break;
      case 'bikes':
        bucketName = _bikesBucket;
        break;
      default:
        bucketName = _profileBucket;
    }
    
    return Supabase.instance.client.storage
        .from(bucketName)
        .getPublicUrl(fileName);
  }

  /// Mevcut kullanÄ±cÄ± ID'sini al
  Future<String?> _getCurrentUserId() async {
    try {
      // Ã–nce Supabase auth'dan al
      final supabaseUser = Supabase.instance.client.auth.currentUser;
      if (supabaseUser?.id != null) {
        return supabaseUser!.id;
      }
      
      // Supabase'den alamazsak backend'den al
      final username = await ServiceLocator.user.getCurrentUsername();
      if (username != null) {
        // Backend'den kullanÄ±cÄ± ID'sini al
        final response = await ServiceLocator.api.get('users/$username/profile/');
        if (response.statusCode == 200 && response.data != null) {
          final userData = response.data;
          return userData['id']?.toString();
        }
      }
      
      return null;
    } catch (e) {
      print('ðŸ”¥ User ID alma hatasÄ±: $e');
      return null;
    }
  }

  /// Eski profil fotoÄŸrafÄ±nÄ± sil
  Future<void> _deleteOldProfilePicture(String userId, String bucket) async {
    try {
      // KullanÄ±cÄ±nÄ±n profil fotoÄŸrafÄ± klasÃ¶rÃ¼ndeki tÃ¼m dosyalarÄ± listele
      final files = await Supabase.instance.client.storage
          .from(bucket)
          .list(path: 'users/$userId/');
      
      // Profil fotoÄŸraflarÄ±nÄ± bul ve sil
      for (final file in files) {
        if (file.name.startsWith('profile_')) {
          try {
            await Supabase.instance.client.storage
                .from(bucket)
                .remove(['users/$userId/${file.name}']);
            print('ðŸ”¥ Eski profil fotoÄŸrafÄ± silindi: ${file.name}');
          } catch (e) {
            print('ðŸ”¥ Profil fotoÄŸrafÄ± silme hatasÄ±: $e');
          }
        }
      }
    } catch (e) {
      print('ðŸ”¥ Eski profil fotoÄŸrafÄ± listeleme hatasÄ±: $e');
    }
  }

  /// Eski kapak fotoÄŸrafÄ±nÄ± sil
  Future<void> _deleteOldCoverPicture(String userId, String bucket) async {
    try {
      // KullanÄ±cÄ±nÄ±n kapak fotoÄŸrafÄ± klasÃ¶rÃ¼ndeki tÃ¼m dosyalarÄ± listele
      final files = await Supabase.instance.client.storage
          .from(bucket)
          .list(path: 'users/$userId/');
      
      // Kapak fotoÄŸraflarÄ±nÄ± bul ve sil
      for (final file in files) {
        if (file.name.startsWith('cover_')) {
          try {
            await Supabase.instance.client.storage
                .from(bucket)
                .remove(['users/$userId/${file.name}']);
            print('ðŸ”¥ Eski kapak fotoÄŸrafÄ± silindi: ${file.name}');
          } catch (e) {
            print('ðŸ”¥ Kapak fotoÄŸrafÄ± silme hatasÄ±: $e');
          }
        }
      }
    } catch (e) {
      print('ðŸ”¥ Eski kapak fotoÄŸrafÄ± listeleme hatasÄ±: $e');
    }
  }

  /// Bir sonraki event klasÃ¶r numarasÄ±nÄ± al
  Future<int> _getNextEventFolderNumber() async {
    try {
      // events klasÃ¶rÃ¼ndeki tÃ¼m alt klasÃ¶rleri listele
      final files = await Supabase.instance.client.storage
          .from(_eventsBucket)
          .list(path: 'events/');
      
      print('ðŸ”¥ Events klasÃ¶rÃ¼ndeki dosyalar: ${files.map((f) => f.name).toList()}');
      
      // Sadece klasÃ¶rleri filtrele (numaralÄ± olanlar)
      final folders = files.where((file) => 
        file.name != null && 
        RegExp(r'^\d+$').hasMatch(file.name)
      ).toList();
      
      print('ðŸ”¥ NumaralÄ± klasÃ¶rler: ${folders.map((f) => f.name).toList()}');
      
      if (folders.isEmpty) {
        // Ä°lk klasÃ¶r: 5 (3 ve 4 zaten mevcut olduÄŸu iÃ§in)
        return 5;
      }
      
      // Mevcut klasÃ¶r numaralarÄ±nÄ± al ve en bÃ¼yÃ¼ÄŸÃ¼nÃ¼ bul
      final numbers = folders.map((folder) => int.tryParse(folder.name ?? '0') ?? 0).toList();
      final maxNumber = numbers.isEmpty ? 0 : numbers.reduce((a, b) => a > b ? a : b);
      
      // Bir sonraki numara
      return maxNumber + 1;
    } catch (e) {
      print('ðŸ”¥ Event klasÃ¶r numarasÄ± alma hatasÄ±: $e');
      // Hata durumunda 5'ten baÅŸla
      return 5;
    }
  }

  /// Bir sonraki grup klasÃ¶r numarasÄ±nÄ± al
  Future<int> _getNextGroupFolderNumber() async {
    try {
      // groups klasÃ¶rÃ¼ndeki tÃ¼m alt klasÃ¶rleri listele
      final files = await Supabase.instance.client.storage
          .from(_groupsBucket)
          .list(path: 'groups/');
      
      print('ðŸ”¥ Groups klasÃ¶rÃ¼ndeki dosyalar: ${files.map((f) => f.name).toList()}');
      
      // Sadece klasÃ¶rleri filtrele (numaralÄ± olanlar)
      final folders = files.where((file) => 
        file.name != null && 
        RegExp(r'^\d+$').hasMatch(file.name)
      ).toList();
      
      print('ðŸ”¥ NumaralÄ± grup klasÃ¶rleri: ${folders.map((f) => f.name).toList()}');
      
      if (folders.isEmpty) {
        // Ä°lk klasÃ¶r: 1
        return 1;
      }
      
      // Mevcut klasÃ¶r numaralarÄ±nÄ± al ve en bÃ¼yÃ¼ÄŸÃ¼nÃ¼ bul
      final numbers = folders.map((folder) => int.tryParse(folder.name ?? '0') ?? 0).toList();
      final maxNumber = numbers.isEmpty ? 0 : numbers.reduce((a, b) => a > b ? a : b);
      
      // Bir sonraki numara
      return maxNumber + 1;
    } catch (e) {
      print('ðŸ”¥ Group klasÃ¶r numarasÄ± alma hatasÄ±: $e');
      // Hata durumunda 1'den baÅŸla
      return 1;
    }
  }
}
